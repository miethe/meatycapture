# MeatyCapture Architecture: Code Examples & Patterns

This document provides concrete code examples and patterns found in the MeatyCapture codebase.

---

## 1. Domain Model Examples

### 1.1 Working with Projects

```typescript
// From src/core/models/index.ts
import type { Project } from '@core/models';

// Creating project data (timestamps auto-generated by store)
const newProject: Omit<Project, 'id' | 'created_at' | 'updated_at'> = {
  name: 'My Project',
  default_path: '~/projects/my-project',
  repo_url: 'https://github.com/user/repo',
  enabled: true,
};

// Using with ProjectStore
const projectStore = createProjectStore();
const project = await projectStore.create(newProject);
console.log(project.id); // auto-generated slug, e.g., 'my-project'
console.log(project.created_at); // Date object
```

### 1.2 Building Documents

```typescript
// From existing CLI pattern (src/cli/index.ts)
import type { RequestLogDoc, RequestLogItem, ItemDraft } from '@core/models';
import { generateDocId } from '@core/validation';
import { aggregateTags, updateItemsIndex } from '@core/serializer';
import { realClock } from '@adapters/clock';

const drafts: ItemDraft[] = [
  {
    title: 'Add dark mode',
    type: 'enhancement',
    domain: 'web',
    context: 'Settings page redesign',
    priority: 'medium',
    status: 'triage',
    tags: ['ux', 'enhancement'],
    notes: 'Users request dark mode for nighttime reading.',
  },
];

const now = realClock.now();
const docId = generateDocId('my-project', now);

// Convert drafts to persisted items
const items: RequestLogItem[] = drafts.map((draft, idx) => ({
  ...draft,
  id: `${docId}-${String(idx + 1).padStart(2, '0')}`, // REQ-20251227-my-project-01
  created_at: now,
}));

// Build complete document
const doc: RequestLogDoc = {
  doc_id: docId,
  title: 'Request Log - My Project',
  project_id: 'my-project',
  items,
  items_index: updateItemsIndex(items), // Extracts id, type, title
  tags: aggregateTags(items), // Unique sorted: ['enhancement', 'ux']
  item_count: items.length,
  created_at: now,
  updated_at: now,
};
```

---

## 2. Validation & ID Generation Patterns

### 2.1 ID Generation

```typescript
import { generateDocId, generateItemId, getNextItemNumber } from '@core/validation';

// Generate document ID
const date = new Date('2025-12-27');
const docId = generateDocId('my-project', date);
// Result: 'REQ-20251227-my-project'

// Generate item ID
const itemId = generateItemId(docId, 1);
// Result: 'REQ-20251227-my-project-01'

// Get next item number from existing items
const existingItems = [
  { id: 'REQ-20251227-my-project-01' },
  { id: 'REQ-20251227-my-project-02' },
  { id: 'REQ-20251227-my-project-05' }, // Non-sequential
];
const nextNumber = getNextItemNumber(existingItems);
// Result: 6 (max of 5 + 1)
```

### 2.2 Parsing & Validation

```typescript
import {
  parseDocId,
  parseItemId,
  isValidDocId,
  isValidItemId,
  slugify,
  sanitizePathSegment,
} from '@core/validation';

// Parse document ID
const parsed = parseDocId('REQ-20251227-my-project');
if (parsed) {
  console.log(parsed.date); // Date(2025-12-27)
  console.log(parsed.projectSlug); // 'my-project'
} else {
  console.log('Invalid ID format');
}

// Validate IDs
if (isValidDocId('REQ-20251227-my-project')) {
  // Safe to use
}

// Normalize text
console.log(slugify('My Project Name'));
// Result: 'my-project-name'

console.log(sanitizePathSegment('../etc/passwd'));
// Result: 'etcpasswd' (path traversal safe)
```

---

## 3. Serialization Patterns

### 3.1 Serialize Document to Markdown

```typescript
import { serialize } from '@core/serializer';
import type { RequestLogDoc } from '@core/models';

const doc: RequestLogDoc = {
  // ... (populated as shown above)
};

const markdown = serialize(doc);
console.log(markdown);
// Output:
// ---
// type: request-log
// doc_id: REQ-20251227-my-project
// title: Request Log - My Project
// project_id: my-project
// item_count: 1
// tags: [enhancement, ux]
// items_index:
//   - id: REQ-20251227-my-project-01
//     type: enhancement
//     title: Add dark mode
// created_at: 2025-12-27T...Z
// updated_at: 2025-12-27T...Z
// ---
//
// ## REQ-20251227-my-project-01 - Add dark mode
//
// **Type:** enhancement | **Domain:** web | **Priority:** medium | **Status:** triage
// **Tags:** enhancement, ux
// **Context:** Settings page redesign
//
// ### Problem/Goal
// Users request dark mode for nighttime reading.
```

### 3.2 Parse Markdown Back to Document

```typescript
import { parse } from '@core/serializer';

const markdown = `---
type: request-log
doc_id: REQ-20251227-my-project
...
---

## REQ-20251227-my-project-01 - Add dark mode
...
`;

try {
  const doc = parse(markdown);
  console.log(doc.doc_id);
  console.log(doc.items.length);
  console.log(doc.tags); // Already aggregated
} catch (error) {
  console.error('Parse error:', error.message);
}
```

### 3.3 Tag Aggregation & Index Updates

```typescript
import { aggregateTags, updateItemsIndex } from '@core/serializer';
import type { RequestLogItem, ItemIndexEntry } from '@core/models';

const items: RequestLogItem[] = [
  {
    id: 'REQ-20251227-my-project-01',
    title: 'Add dark mode',
    type: 'enhancement',
    tags: ['ux', 'enhancement'],
    // ... other fields
    created_at: new Date(),
  },
  {
    id: 'REQ-20251227-my-project-02',
    title: 'Fix login bug',
    type: 'bug',
    tags: ['bug', 'auth'],
    // ... other fields
    created_at: new Date(),
  },
];

// Aggregate tags from all items
const allTags = aggregateTags(items);
console.log(allTags); // ['auth', 'bug', 'enhancement', 'ux'] - sorted, unique

// Create quick-reference index
const index: ItemIndexEntry[] = updateItemsIndex(items);
console.log(index);
// [
//   { id: 'REQ-20251227-my-project-01', type: 'enhancement', title: 'Add dark mode' },
//   { id: 'REQ-20251227-my-project-02', type: 'bug', title: 'Fix login bug' },
// ]
```

---

## 4. Storage Adapter Patterns

### 4.1 File System Adapter Usage

```typescript
import { createFsDocStore } from '@adapters/fs-local';
import type { RequestLogDoc } from '@core/models';

const docStore = createFsDocStore();

// Write document
const doc: RequestLogDoc = { /* ... */ };
const path = '/Users/name/.meatycapture/docs/my-project/REQ-20251227-my-project.md';

try {
  // Automatically creates backup: REQ-20251227-my-project.md.bak
  await docStore.write(path, doc);
  console.log('Document written successfully');
} catch (error) {
  console.error('Write failed:', error.message);
}

// Read document
try {
  const readDoc = await docStore.read(path);
  console.log(`Loaded ${readDoc.item_count} items`);
} catch (error) {
  console.error('Read failed:', error.message);
}

// List documents in directory
const docs = await docStore.list('/Users/name/.meatycapture/docs/my-project');
// Returns: Array of DocMeta { path, doc_id, title, item_count, updated_at }
// Sorted by updated_at descending

docs.forEach((doc) => {
  console.log(`${doc.doc_id}: ${doc.item_count} items (${doc.updated_at.toISOString()})`);
});

// Append item to existing document
const itemDraft = {
  title: 'New item',
  type: 'bug',
  domain: 'api',
  context: 'Auth service',
  priority: 'high',
  status: 'triage',
  tags: ['bug', 'critical'],
  notes: 'Login token expiration not handled.',
};

const updated = await docStore.append(path, itemDraft, realClock);
console.log(`Document now has ${updated.item_count} items`);
console.log(`Tags: ${updated.tags.join(', ')}`);
```

### 4.2 Config Adapter Usage

```typescript
import { createProjectStore, createFieldCatalogStore } from '@adapters/config-local';

// === PROJECT MANAGEMENT ===
const projectStore = createProjectStore();

// List all projects
const projects = await projectStore.list();
projects.forEach((p) => console.log(`${p.id}: ${p.name}`));

// Get specific project
const proj = await projectStore.get('my-project');
if (proj) {
  console.log(`Default path: ${proj.default_path}`);
}

// Create new project
const newProject = await projectStore.create({
  name: 'New Project',
  default_path: '~/projects/new-project',
  repo_url: 'https://github.com/user/new-project',
  enabled: true,
});
console.log(`Created: ${newProject.id}`);

// Update project
const updated = await projectStore.update('my-project', {
  enabled: false, // Disable project
});

// Delete project (note: doesn't cascade delete documents)
await projectStore.delete('old-project');

// === FIELD CATALOG ===
const fieldStore = createFieldCatalogStore();

// Get global field options
const globalOptions = await fieldStore.getGlobal();
// Example: [
//   { id: 'f1', field: 'type', value: 'enhancement', scope: 'global' },
//   { id: 'f2', field: 'type', value: 'bug', scope: 'global' },
//   { id: 'f3', field: 'priority', value: 'high', scope: 'global' },
// ]

// Get effective options for a project (global + project-specific)
const projectOptions = await fieldStore.getForProject('my-project');

// Get options for specific field
const typeOptions = await fieldStore.getByField('type');
const customDomains = await fieldStore.getByField('domain', 'my-project');

// Add new field option (project-specific)
const newOption = await fieldStore.addOption({
  field: 'domain',
  value: 'mobile-app',
  scope: 'project',
  project_id: 'my-project',
});

// Remove option
await fieldStore.removeOption(newOption.id);
```

---

## 5. Type Guards & Runtime Validation

### 5.1 Core Model Validation

```typescript
import {
  isProject,
  isFieldOption,
  isItemDraft,
  isRequestLogItem,
  isRequestLogDoc,
  type Project,
  type ItemDraft,
} from '@core/models';

// Validate project
const data = JSON.parse(someJson);
if (isProject(data)) {
  const project: Project = data; // Type-safe
  console.log(project.name);
}

// Validate item draft
const input = JSON.parse(userInput);
if (isItemDraft(input)) {
  const draft: ItemDraft = input;
  console.log(`Creating item: ${draft.title}`);
} else {
  console.error('Invalid item format');
}

// Validate complete document
const docData = JSON.parse(fileContents);
if (isRequestLogDoc(docData)) {
  console.log(`Loaded document: ${docData.doc_id}`);
} else {
  console.error('Document structure invalid');
}
```

### 5.2 CLI Input Validation (Existing Pattern)

```typescript
// From src/cli/index.ts
import type { ItemDraft } from '@core/models';

interface CliInput {
  project: string;
  title?: string;
  items: ItemDraft[];
}

function isValidCliInput(obj: unknown): obj is CliInput {
  if (!obj || typeof obj !== 'object') return false;
  const input = obj as Partial<CliInput>;

  // Validate project
  if (!input.project || typeof input.project !== 'string') return false;

  // Validate items array
  if (!Array.isArray(input.items) || input.items.length === 0) return false;

  // Validate each item
  for (const item of input.items) {
    if (!isValidItemDraft(item)) return false;
  }

  // Validate optional title
  if (input.title !== undefined && typeof input.title !== 'string') return false;

  return true;
}

// Usage
const jsonInput = JSON.parse(rawJson);
if (isValidCliInput(jsonInput)) {
  // Safely process input
  console.log(`Project: ${jsonInput.project}`);
  console.log(`Items: ${jsonInput.items.length}`);
}
```

---

## 6. Filtering & Catalog Patterns

### 6.1 Document Filtering

```typescript
import {
  filterByProject,
  filterByType,
  filterByPriority,
  filterByText,
  applyFilters,
} from '@core/catalog';
import type { CatalogEntry, FilterState } from '@core/catalog';

const entries: CatalogEntry[] = [
  // Catalog entries with project + doc + item metadata
];

// Apply single filter
const webItems = filterByType(entries, 'bug');

// Apply multiple filters
const filters: FilterState = {
  project: 'my-project',
  type: 'enhancement',
  priority: 'high',
  status: 'backlog',
  tags: ['ux', 'api'], // AND logic: must have both
  text: 'dark mode', // Search in title and notes
  domain: undefined, // Not filtered
};

const filtered = applyFilters(entries, filters);
console.log(`Found ${filtered.length} items matching criteria`);
```

### 6.2 Catalog Grouping & Sorting

```typescript
import { groupByProject, sortDocuments, createGroupedCatalog } from '@core/catalog';
import type { CatalogEntry, GroupedCatalog } from '@core/catalog';

const entries: CatalogEntry[] = [
  // ... mixed documents from multiple projects
];

// Group by project
const grouped = groupByProject(entries);
// Result: { 'project-a': [...], 'project-b': [...] }

// Sort documents within groups
const sortedDocs = sortDocuments(entries, {
  field: 'updated_at',
  order: 'desc',
});

// Create full grouped + sorted catalog
const catalog: GroupedCatalog = createGroupedCatalog(entries, {
  field: 'updated_at',
  order: 'desc',
});

// Use in UI
catalog.projects.forEach((projectGroup) => {
  console.log(`Project: ${projectGroup.id}`);
  projectGroup.docs.forEach((doc) => {
    console.log(`  - ${doc.title}: ${doc.item_count} items`);
  });
});
```

---

## 7. Logging Patterns

### 7.1 Structured Logging

```typescript
import { logger } from '@core/logging';
import { LogLevel } from '@core/logging';

// Basic logging
logger.info('Document created', { doc_id: 'REQ-20251227-app', path: '/path/to/doc.md' });
logger.warn('Backup failed', { reason: 'Permission denied' });
logger.error('Write failed', { error: error.message, path });

// Debug logging (only shows if LOG_LEVEL=debug)
logger.debug('Parsing document', { size: 1024, lines: 50 });

// Configure log level at runtime
logger.configure({ minLevel: LogLevel.DEBUG });
```

### 7.2 Environment-Based Configuration

```typescript
// Set environment variables
// For Node.js: LOG_LEVEL=debug
// For browser: VITE_LOG_LEVEL=debug

// Logger automatically picks up from environment on initialization
// Can also configure at runtime:
import { logger } from '@core/logging';

if (process.env.DEBUG) {
  logger.configure({ minLevel: 0 }); // LogLevel.DEBUG
}
```

---

## 8. CLI Command Pattern (Existing)

### 8.1 Command Structure

```typescript
// From src/cli/index.ts
import { Command } from 'commander';

async function createCommand(jsonPath: string, options: { output?: string }): Promise<void> {
  try {
    // 1. Read & validate input
    const input = await readCliInput(jsonPath);

    // 2. Resolve output path
    let outputPath: string;
    if (options.output) {
      outputPath = resolve(options.output);
    } else {
      const projectPath = await getProjectDocPath(input.project);
      const now = realClock.now();
      const docId = generateDocId(input.project, now);
      outputPath = join(projectPath, `${docId}.md`);
    }

    // 3. Build document from core functions
    const now = realClock.now();
    const docId = generateDocId(input.project, now);
    const items = input.items.map((itemDraft, index) => ({
      ...itemDraft,
      id: `${docId}-${String(index + 1).padStart(2, '0')}`,
      created_at: now,
    }));

    const doc: RequestLogDoc = {
      doc_id: docId,
      title: input.title || `Request Log - ${input.project}`,
      project_id: input.project,
      items,
      items_index: updateItemsIndex(items),
      tags: aggregateTags(items),
      item_count: items.length,
      created_at: now,
      updated_at: now,
    };

    // 4. Write via adapter
    const docStore = createFsDocStore();
    await docStore.write(outputPath, doc);

    // 5. Output success
    console.log(`✓ Created document: ${outputPath}`);
    console.log(`  Doc ID: ${docId}`);
    console.log(`  Items: ${items.length}`);
    console.log(`  Tags: ${doc.tags.join(', ')}`);

    process.exit(0);
  } catch (error) {
    console.error('Error creating document:');
    console.error(error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}

const program = new Command();
program
  .name('meatycapture')
  .description('Headless batch document creation')
  .version('0.1.0');

program
  .command('create')
  .description('Create a new request-log document from JSON input')
  .argument('<json-file>', 'Path to JSON input file')
  .option('-o, --output <path>', 'Output path for the document')
  .action(createCommand);

program.parse();
```

### 8.2 JSON Input Format

```json
{
  "project": "my-project",
  "title": "Optional document title",
  "items": [
    {
      "title": "Item title",
      "type": "enhancement",
      "domain": "web",
      "context": "Additional context",
      "priority": "medium",
      "status": "triage",
      "tags": ["tag1", "tag2"],
      "notes": "Problem/goal description"
    }
  ]
}
```

---

## 9. Path Resolution Patterns

### 9.1 Smart Default Paths

```typescript
// From CLI (src/cli/index.ts)
import { join } from 'node:path';
import { homedir } from 'node:os';

async function getProjectDocPath(projectId: string): Promise<string> {
  // 1. Check if project exists and has configured path
  const projectStore = createProjectStore();
  const project = await projectStore.get(projectId);
  if (project) {
    return project.default_path;
  }

  // 2. Check environment variable
  const envPath = process.env['MEATYCAPTURE_DEFAULT_PROJECT_PATH'];
  if (envPath) {
    return join(envPath, projectId);
  }

  // 3. Fallback to default
  return join(homedir(), '.meatycapture', 'docs', projectId);
}

// Path expansion (handles tilde)
function expandPath(path: string): string {
  if (path.startsWith('~/')) {
    return join(homedir(), path.slice(2));
  }
  return path;
}
```

---

## 10. Type Safety in Adapters

### 10.1 Generic Store Implementation

```typescript
// Pattern used in both fs-local and config-local
import type { DocStore, ProjectStore, FieldCatalogStore } from '@core/ports';
import type { RequestLogDoc, Project, FieldOption } from '@core/models';

export class FsDocStore implements DocStore {
  async list(directory: string): Promise<DocMeta[]> {
    // Implementation returns strongly-typed DocMeta[]
  }

  async read(path: string): Promise<RequestLogDoc> {
    // Implementation returns RequestLogDoc
    // Parsing validates structure via type guards
  }

  async write(path: string, doc: RequestLogDoc): Promise<void> {
    // Type-safe: doc parameter is RequestLogDoc
    // Can't pass wrong structure
  }

  async append(path: string, item: ItemDraft, clock: Clock): Promise<RequestLogDoc> {
    // Type-safe parameter + return
  }
}

export class LocalProjectStore implements ProjectStore {
  // Similar implementation for projects
}

export class LocalFieldCatalogStore implements FieldCatalogStore {
  // Similar implementation for field options
}
```

---

## 11. Testing Patterns

### 11.1 Mock Clock for Deterministic Tests

```typescript
import type { Clock } from '@core/ports';
import { realClock } from '@adapters/clock';

// For testing, create a mock clock
class MockClock implements Clock {
  constructor(private fixedDate: Date = new Date('2025-12-27')) {}

  now(): Date {
    return this.fixedDate;
  }
}

// Usage in tests
const mockClock = new MockClock(new Date('2025-12-27'));
const now = mockClock.now();
const docId = generateDocId('test-project', now);
// Always produces same ID: REQ-20251227-test-project
```

### 11.2 Snapshot Testing for Serialization

```typescript
import { serialize, parse } from '@core/serializer';

describe('Serializer', () => {
  it('serializes document to markdown', () => {
    const doc: RequestLogDoc = { /* ... */ };
    const markdown = serialize(doc);

    // Snapshot comparison ensures format doesn't change
    expect(markdown).toMatchSnapshot();
  });

  it('round-trips: parse(serialize(doc)) === doc', () => {
    const original: RequestLogDoc = { /* ... */ };
    const markdown = serialize(original);
    const parsed = parse(markdown);

    expect(parsed).toEqual(original);
  });
});
```

---

## Summary

These patterns demonstrate how to:

1. **Work with Models:** Create typed entities, use type guards for validation
2. **Validate Input:** CLI input validation, ID validation, format checking
3. **Serialize/Deserialize:** Convert between domain models and markdown
4. **Use Adapters:** Create documents, query projects, manage field options
5. **Filter & Catalog:** Organize and search documents by multiple criteria
6. **Log Operations:** Structured logging with context
7. **Build CLI Commands:** Validate input → use core → output results
8. **Handle Paths:** Smart defaults, tilde expansion, sanitization
9. **Ensure Type Safety:** Implement ports, use generics, avoid type errors
10. **Test Effectively:** Mock dependencies, snapshot comparisons, deterministic time

All patterns are currently in use in the codebase, making them proven and maintainable.
